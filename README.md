# queue
[![Build Status](https://travis-ci.org/illinois/queue.svg?branch=master)](https://travis-ci.org/illinois/queue)

## Running locally in `dev` mode:
- Clone the repository
- Install [`node` and `npm`](https://nodejs.org/en/download/package-manager/)
- Install [`MySQL`](https://www.mysql.com/)
  - You should create a user named `queue` and a database also named `queue`. See below for specific instructions.
- Install dependencies: `npm install` in the `queue` directory
- In `models/index.js`, uncomment `sequelize.sync({force: true})`
  - Comment this line after the first run if you do not want databases to be dropped and rebuilt on startup
- Start the server: `npm run dev`
  - Access the queue from a browser at `localhost:3000`

##### Setting up MySQL

The queue runs with a specific MySQL username and database, both of which are
named `queue`. This is configured in `config/config.json` and can vary between
development, staging, and production environments.

To create the database for development:

```sql
CREATE DATABASE queue;
```

Now, you can create the `queue` user and grant its permissions:

```sql
CREATE USER 'queue'@'localhost';
GRANT ALL PRIVILEGES ON *.* TO 'queue'@'localhost';
```

If you want to run the test suite, it's important that the `queue` user be able to create and destroy databases. Keep that in mind if you decide to change the privileges of the `queue` user.

## Database Migrations

We use [Sequelize](http://docs.sequelizejs.com/) as an ORM to make interacting with our database easier. However, its build-in support for migrations is primitive and hard to automate, so Queue includes its own migration support.

Our philosophy is that the Sequelize model definitions in `models/` should serve as the source of truth for what the database should look like at any given repository state. However, because Sequelize can't automatically mutate the database schema to bring it up-to-date with what's expected, we track each change to the database schema so that we can smoothly update the database whenever the schema changes.

Migrations live in the `migrations/` directory and are named like `###_MY_MIGRATION_NAME.sql`. Each one represents a set of database schema changes, which can include adding or removing columns or tables. They are explicitly ordered and uniquely identified by the number at the beginning of their name. A migration should take the existing schema and transform it in such as way that it matches the schema that would be generated by running Sequelize's `sync({ force: true })`. This is enforced by our test suite and CI: if a PR would result in the migration chain being out of sync with the Sequelize models, the build will fail.

### How to modify the database schema

To modify a model definition, you only need to do two things:

- Update the appropriate model definitions in `models/`. Remember that these serve as the source of truth for the database schema.

- Write a migration in `migrations/`. It should use the next available index number and exactly mirror the changes made in the Sequelize model definition. If you're unsure of what this query would look like, you can run the test suite and look at the failure message for the database tests. This will contain one or more queries that should bring the database into the correct state.

Once a migration has been merged into `master`, it should be treated as immutable. Modifying an old migration could produce unintended consequences if future migrations depend on it.

### Technical details of migrations

Migrations are tracked in a `migrations` table, which stores the index of the migration, its filename, and when it was applied.

The following steps occur when the app starts up in order to perform migrations (these are implemented in `migrations/index.js`):

1. The database is queried to find the index of the last migration that was applied.

2. All `.sql` files from `migrations` are read, parsed, and sorted by index.

3. Each one is applied to the database sequentially in order. When a migration is successfully applied, an entry is created in the `migrations` table so that that migration won't be applied again.

## Multiple users in dev mode
In production, all auth is done my Shibboleth, and we just read out of the `eppn` header
to get a student's identity. In dev mode, we still want to be able to test with multiple
users (for instance, to assert that user roles work correctly, or to ensue that syncing
between multiple clients works correctly). To achieve that, we use `express-session` to
track users across page reloads. By default, you will assume the role of `dev`, an admin
user. To force a different user, you can append `?forceuser=NETID` to any URL (this creates
a user NETID if needed). All future requests from that browser will be associated with that
user, and you can add it to course staff, etc. like a normal user.

To test with multiple users at the same time, you can open up multiple browsers, or use
multiple incognito windows.

## Production config
Several configuration options are exposed via environment variables:

* `PORT`: controls which port the app will be served from.
* `BASE_URL`: allows the app to be served from somewhere other than the server
  root. This affects asset and API routes, websocket endpoints, generated links,
  and more. Note that for this to work effectively, the app must still receive
  the base URL as part of the request; this is important if the app is
  reverse-proxied behind Apache. For instance, if the queue is served from
  `/my/path/`, then you should run with `BASE_URL=/my/path` (note the lack of
  trailing slash), and a request for queue 1 should be received as `/my/path/queue/1`.
